import copy
import itertools
import logging
import re
import sys
import time

from collections import defaultdict

import numpy as np
import pandas as pd

import pylib.aochelper as aoc
#from pylib.aochelper import map_list as mapl
#from pylib.aochelper import filter_list as filterl

f"Python version: {sys.version}" |> print
f"Version info: {sys.version_info}" |> print

log = aoc.getLogger(__name__)
f"Initial log-level={aoc.getLogLevelName(log.getEffectiveLevel())}." |> print

"Day 1" |> print

tests = """
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
""".strip()

def solve_day01pt1(inp):
  """Solve Day 1 part 1."""
  reindeers = inp.split("\n\n") |> fmap$( x -> x.split("\n") |> fmap$(int) )
  #reindeers |> print
  return reindeers |> map$(sum) |> max

"Day 1 part 1" |> print
expected = 24_000
result = solve_day01pt1(tests)
aoc.assert_msg(f"test solve day 1 part 1 expected={expected} result={result}", result == expected)

ins = aoc.read_file_to_str("./in/day01.in").strip()
out = solve_day01pt1(ins)
f"day 1 part 1 output: {out}" |> print

def solve_day01pt2(inp):
  """Solve Day 1 part 2."""
  reindeers = inp.split("\n\n") |> fmap$( x -> x.split("\n") |> fmap$(int) )
  top3 = reindeers |> fmap$(sum) |> sorted$(reverse=True) |> .[0:3]
  return top3 |> sum

"Day 1 part 2" |> print
expected = 45_000
result = solve_day01pt2(tests)
aoc.assert_msg(f"test solve day 1 part 1 expected={expected} result={result}", result == expected)

out = solve_day01pt2(ins)
f"day 1 part 2 output: {out}" |> print

tests = """
A Y
B X
C Z
""".strip()

values = {'X': 1, 'Y': 2, 'Z': 3}
outcomes = {
  'A': {'X': 3, 'Y': 6, 'Z': 0},
  'B': {'X': 0, 'Y': 3, 'Z': 6},
  'C': {'X': 6, 'Y': 0, 'Z': 3},
}

def solve_day02pt1(inp):
  """Solve Day 2 part 1."""
  score = 0
  for line in inp.splitlines():
    [p1, p2] = line.split()
    #f"[p1, p2] = {[p1, p2]}" |> print
    round_score = values[p2]  # item value score
    round_score += outcomes[p1][p2]  # outcome score
    #f"adding round score {round_score}" |> print
    score += round_score
  return score

"Day 2 part 1" |> print
expected = 15
result = solve_day02pt1(tests)
aoc.assert_msg(f"test solve day 2 part 1 expected={expected} result={result}", result == expected)

ins = aoc.read_file_to_str("./in/day02.in").strip()
out = solve_day02pt1(ins)
f"day 2 part 1 output: {out}" |> print

def solve_day02pt2(inp):
  """Solve Day 2 part 2."""
  outcome_tags = {'X': 0, 'Y': 3, 'Z': 6}  # who wins on pt 2
  outcomes_inv = {}
  for k, innerdict in outcomes.items():
    #outcomes_inv[k] = dict((v, k) for k, v in innerdict.items())  # keys and values swapped
    outcomes_inv[k] = {v: k for k, v in innerdict.items()}  # keys and values swapped
  #f"outcomes_inverse={outcomes_inv}" |> print
  score = 0
  for line in inp.splitlines():
    [p1, o2] = line.split()
    round_score = outcome_tags[o2]
    p2 = outcomes_inv[p1][round_score]  # my item (player 2)
    round_score += values[p2]  # outcome score
    #f"adding round score {round_score} from item={p2}" |> print
    score += round_score
  return score

"Day 2 part 2" |> print
expected = 12
result = solve_day02pt2(tests)
aoc.assert_msg(f"test solve day 2 part 2 expected={expected} result={result}", result == expected)

out = solve_day02pt2(ins)
f"day 2 part 2 output: {out}" |> print

tests = """
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
""".strip()

def split_str_halfs(s):
  """Split a string in two of equel length"""
  pos = len(s)//2
  return [s[:pos], s[pos:]]

def solve_day03pt1(inp):
  """Solve Day 3 part 1."""
  score = 0
  ofst_lower = ord("a") - 1
  ofst_upper = ord("A") - 27
  for line in inp.splitlines():
    sh1, sh2 = split_str_halfs(line)
    #[sh1, sh2] |> print
    freqh1, freqh2 = [defaultdict(int), defaultdict(int)]
    for c in sh1:
      freqh1[c] += 1
    for c in sh2:
      freqh2[c] += 1
    isct = set(freqh1.keys()).intersection(set(freqh2.keys()))
    assert len(isct) == 1
    isct = list(isct)[0]
    if isct.isupper():
      prio = ord(isct) - ofst_upper
    else:
      prio = ord(isct) - ofst_lower
    score += prio
    #f"set-intersection={isct}, prio={prio}" |> print
  return score

"Day 3 part 1" |> print
expected = 157
result = solve_day03pt1(tests)
aoc.assert_msg(f"test solve day 3 part 1 expected={expected} result={result}", result == expected)

ins = aoc.read_file_to_str("./in/day03.in").strip()
out = solve_day03pt1(ins)
f"day 3 part 1 output: {out}" |> print

def solve_day03pt2(inp):
  """Solve Day 3 part 2."""
  score = 0
  ofst_lower = ord("a") - 1
  ofst_upper = ord("A") - 27
  grp = []
  for idx, line in enumerate(inp.splitlines()):
    grp.append(line)
    if len(grp) == 3:
      tgtset = set()
      for idx, memb in enumerate(grp):
        freqs = defaultdict(int)
        for c in memb:
          freqs[c] += 1
        if idx==0:
          tgtset = set(freqs.keys())
        else:
          tgtset = tgtset.intersection(freqs.keys())
      grp = []
      assert len(tgtset) == 1
      un = list(tgtset)[0]
      if un.isupper():
        prio = ord(un) - ofst_upper
      else:
        prio = ord(un) - ofst_lower
      #f"grp set-intersection={tgtset}, prio={prio}" |> print
      score += prio
  assert idx > 0 
  assert (idx+1) % 3 == 0
  return score

"Day 3 part 2" |> print
expected = 70
result = solve_day03pt2(tests)
aoc.assert_msg(f"test solve day 3 part 2 expected={expected} result={result}", result == expected)

out = solve_day03pt2(ins)
f"day 3 part 2 output: {out}" |> print

day = "Day 4"
symb = "day04"
part = "part 1"
tests = """
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
""".strip()

def has_fully_containment(e1, e2):
  return (e1[0] <= e2[0] and e1[1] >= e2[1]) or (e2[0] <= e1[0] and e2[1] >= e1[1])

def solve_day04pt1(inp):
  """Solve Day 4 part 1."""
  score = 0
  #pairs = []
  for line in inp.splitlines():
    elves = line.split(",")
    elves = list(map(lambda it: list(map(int, it.split("-"))), elves))
    if has_fully_containment(elves[0], elves[1]):
      #f"{elves} has fully containment" |> print
      score += 1
  #pairs |> print
  return score

f"{day} {part}" |> print
expected = 2
result = solve_day04pt1(tests)
aoc.assert_msg(f"test solve {day} {part} expected={expected} result={result}", result == expected)

ins = aoc.read_file_to_str(f"./in/{symb}.in").strip()
out = solve_day04pt1(ins)
f"{day} {part} output: {out}" |> print

def has_overlap(e1, e2):
  return (e1[1] >= e2[0] and e1[1] <= e2[1]) or (e2[1] >= e1[0] and e2[1] <= e1[1])

def solve_day04pt2(inp):
  """Solve Day 4 part 2."""
  score = 0
  for line in inp.splitlines():
    elves = line.split(",")
    elves = list(map(lambda it: list(map(int, it.split("-"))), elves))
    if has_overlap(elves[0], elves[1]):
      #f"{elves} has overlap" |> print
      score += 1
  return score

part = "part 2"
expected = 4
f"{day} {part}" |> print
result = solve_day04pt2(tests)
aoc.assert_msg(f"test solve {day} {part} expected={expected} result={result}", result == expected)

ins = aoc.read_file_to_str(f"./in/{symb}.in").strip()
out = solve_day04pt2(ins)
f"{day} {part} output: {out}" |> print


